// Problem 2: Quick Sort
// i. Implement Quick Sort with three pivot strategies (data stored in an 1D array):
// o First element as pivot.
// o Last element as pivot.
// o Median-of-three as pivot.
// ii. For each pivot strategy:
// o Show the partitioning steps (print subarrays at each recursive stage).
// o Count the number of comparisons and swaps.
// iii. Compare the performance of the three strategies on:
// o A sorted array (best/worst case).
// o A reverse-sorted array.
// o A random array.
// Learning Outcome:
// > Role of pivot selection in divide-and-conquer efβiciency.
// > Why Quick Sort’s best/average case is O(n log n) but worst case is O(n2).
// > Practical impact of input data distribution.


